# PiRacer 계기판 검증 계획서

## 📋 문서 정보
- **프로젝트명**: PiRacer Luxury Sports Dashboard
- **버전**: 1.0.0
- **작성일**: 2026-02-16
- **작성자**: Ahn Hyunjun
- **목적**: 계기판 시스템의 기능, 성능, 안정성 검증

---

## 1. 검증 전략

### 1.1 검증 단계

```
┌─────────────────┐
│ 1. 단위 테스트  │ ← 개별 함수/클래스 검증
└────────┬────────┘
         ↓
┌─────────────────┐
│ 2. 통합 테스트  │ ← 모듈 간 통신 검증
└────────┬────────┘
         ↓
┌─────────────────┐
│ 3. 시스템 테스트│ ← 전체 시스템 동작 검증
└────────┬────────┘
         ↓
┌─────────────────┐
│ 4. 실차 테스트  │ ← 실제 환경 검증
└────────┬────────┘
         ↓
┌─────────────────┐
│ 5. 사용성 테스트│ ← UI/UX 검증
└─────────────────┘
```

### 1.2 검증 환경

#### 개발 환경
- **하드웨어**: Raspberry Pi 4 (4GB RAM)
- **디스플레이**: 7인치 DSI 터치스크린 (1200×400)
- **OS**: Raspberry Pi OS (Bullseye)
- **센서**: Arduino Uno + LM393 센서

#### 테스트 도구
- **단위 테스트**: Qt Test Framework
- **성능 측정**: `top`, `htop`, `perf`
- **메모리 분석**: `valgrind`, `heaptrack`
- **시리얼 모니터**: `minicom`, `screen`

---

## 2. 단위 테스트 (Unit Tests)

### 2.1 DataProcessor 테스트

#### 테스트 케이스: TC-DP-001 - Pulse to km/h 변환
```cpp
TEST(DataProcessor, PulseToKmh) {
    DataProcessor dp;
    dp.setCalibration(0.72);  // 예시 계수
    
    EXPECT_FLOAT_EQ(dp.pulseToKmh(0.0), 0.0);
    EXPECT_FLOAT_EQ(dp.pulseToKmh(10.0), 7.2);
    EXPECT_FLOAT_EQ(dp.pulseToKmh(100.0), 72.0);
}
```

| 입력 (pulse/s) | 기대 출력 (km/h) | 허용 오차 |
|----------------|------------------|-----------|
| 0.0 | 0.0 | ±0.01 |
| 10.0 | 7.2 | ±0.1 |
| 50.0 | 36.0 | ±0.5 |
| 100.0 | 72.0 | ±1.0 |

**통과 조건**: 모든 케이스 허용 오차 내

---

#### 테스트 케이스: TC-DP-002 - Pulse to RPM 변환
```cpp
TEST(DataProcessor, PulseToRPM) {
    DataProcessor dp;
    dp.setPulsesPerRevolution(20);
    
    EXPECT_FLOAT_EQ(dp.pulseToRPM(0.0), 0.0);
    EXPECT_FLOAT_EQ(dp.pulseToRPM(20.0), 60.0);  // 1 rev/s = 60 RPM
    EXPECT_FLOAT_EQ(dp.pulseToRPM(100.0), 300.0);
}
```

| 입력 (pulse/s) | 기대 RPM | 허용 오차 |
|----------------|----------|-----------|
| 0.0 | 0.0 | ±0.1 |
| 20.0 | 60.0 | ±1.0 |
| 100.0 | 300.0 | ±5.0 |

**통과 조건**: 모든 케이스 허용 오차 내

---

#### 테스트 케이스: TC-DP-003 - 경계값 테스트
```cpp
TEST(DataProcessor, BoundaryValues) {
    DataProcessor dp;
    
    // 음수 입력 (센서 오류)
    EXPECT_GE(dp.pulseToKmh(-10.0), 0.0);  // 0 이상이어야 함
    
    // 매우 큰 값 (센서 노이즈)
    EXPECT_LT(dp.pulseToKmh(10000.0), 100.0);  // 비현실적 값 제한
}
```

**통과 조건**: 
- 음수 입력 시 0 반환
- 비정상적으로 큰 값 필터링

---

### 2.2 SerialReader 테스트

#### 테스트 케이스: TC-SR-001 - 데이터 파싱
```cpp
TEST(SerialReader, DataParsing) {
    SerialReader reader;
    
    QString line1 = "Pulses: 42 | Speed: 84.00 pulse/s | Time: 12.34 s";
    auto result = reader.parseLine(line1);
    
    EXPECT_TRUE(result.isValid);
    EXPECT_FLOAT_EQ(result.pulsePerSec, 84.0);
    EXPECT_EQ(result.pulseCount, 42);
}
```

| 입력 문자열 | 기대 pulsePerSec | 기대 pulseCount | 유효성 |
|------------|------------------|-----------------|--------|
| "Speed: 84.00 pulse/s" | 84.0 | - | true |
| "Speed: 0.00 pulse/s" | 0.0 | - | true |
| "Invalid data" | - | - | false |
| "" (빈 문자열) | - | - | false |

**통과 조건**: 모든 케이스 올바르게 파싱

---

#### 테스트 케이스: TC-SR-002 - 잘못된 데이터 처리
```cpp
TEST(SerialReader, InvalidData) {
    SerialReader reader;
    
    EXPECT_FALSE(reader.parseLine("").isValid);
    EXPECT_FALSE(reader.parseLine("Garbage text").isValid);
    EXPECT_FALSE(reader.parseLine("Speed: abc pulse/s").isValid);
}
```

**통과 조건**: 잘못된 입력 시 isValid = false

---

### 2.3 CalibrationManager 테스트

#### 테스트 케이스: TC-CM-001 - JSON 로드
```cpp
TEST(CalibrationManager, LoadJSON) {
    CalibrationManager cm;
    bool success = cm.loadFromFile("test_calibration.json");
    
    EXPECT_TRUE(success);
    EXPECT_FLOAT_EQ(cm.getSpeedFactor(), 0.72);
    EXPECT_EQ(cm.getPulsesPerRevolution(), 20);
}
```

**통과 조건**: JSON 파일 정상 로드 및 값 추출

---

## 3. 통합 테스트 (Integration Tests)

### 3.1 시리얼 통신 통합 테스트

#### 테스트 케이스: TC-INT-001 - Arduino ↔ Qt 통신
**목적**: Arduino에서 전송한 데이터가 Qt 애플리케이션에 정확히 도달하는지 검증

**절차**:
1. Arduino를 Raspberry Pi에 USB 연결
2. Dashboard 애플리케이션 실행
3. Arduino에서 고정 속도 데이터 전송 (예: 50 pulse/s)
4. Qt 화면에 표시된 값 확인

**기대 결과**:
- 연결 상태: "Connected"
- 표시 속도: 36.0 km/h (±1.0)
- 지연 시간: < 200ms

**통과 조건**: 
- [ ] 데이터 수신 성공률 > 95%
- [ ] 표시 값 오차 < 5%
- [ ] 연결 안정성 (1분간 끊김 없음)

---

#### 테스트 케이스: TC-INT-002 - 연결 재시도
**목적**: 시리얼 연결 끊김 시 자동 재연결 검증

**절차**:
1. 정상 작동 중 USB 케이블 분리
2. 5초 대기
3. USB 케이블 재연결
4. 자동 재연결 확인

**기대 결과**:
- 연결 끊김 후 "Disconnected" 표시
- 재연결 시도 (5초 간격)
- 재연결 성공 시 데이터 수신 재개

**통과 조건**:
- [ ] 10초 이내 자동 재연결
- [ ] 데이터 손실 최소화

---

### 3.2 Python 브릿지 통합 테스트

#### 테스트 케이스: TC-INT-003 - PiRacer 배터리 읽기
**목적**: Python에서 배터리 데이터를 읽어 Qt에 전달하는지 검증

**절차**:
1. `piracer_bridge.py` 단독 실행
   ```bash
   python3 python/piracer_bridge.py
   ```
2. stdout 출력 확인 (JSON 형식)
3. Qt 애플리케이션에서 QProcess로 실행
4. 화면에 배터리 표시 확인

**기대 결과**:
- JSON 출력: `{"voltage": 7.8, "percent": 85}`
- Qt 화면: 85%, 7.8V 표시
- 업데이트 주기: 0.5초

**통과 조건**:
- [ ] Python 스크립트 정상 실행
- [ ] JSON 파싱 성공
- [ ] 화면 업데이트 정상

---

### 3.3 위젯 동기화 테스트

#### 테스트 케이스: TC-INT-004 - 모든 위젯 동시 업데이트
**목적**: 하나의 속도 데이터로 모든 위젯이 동기화되는지 검증

**절차**:
1. 고정 속도 데이터 입력 (50 pulse/s)
2. 모든 위젯 값 확인:
   - 중앙 속도계: 36.0 km/h
   - 좌측 RPM: 150 RPM
   - 최고 속도: 갱신 여부

**통과 조건**:
- [ ] 모든 위젯 동시 업데이트 (±50ms)
- [ ] 값 일관성 유지
- [ ] 애니메이션 부드러움

---

## 4. 시스템 테스트 (System Tests)

### 4.1 기능 테스트

#### 테스트 케이스: TC-SYS-001 - 속도 표시 정확성
**목적**: 실제 속도와 표시 속도의 오차 측정

**준비물**:
- 줄자 (10m 직선 거리)
- 스톱워치
- PiRacer

**절차**:
1. 10m 직선 거리 표시
2. PiRacer를 일정 속도로 주행
3. 시간 측정 (스톱워치)
4. 화면 표시 속도 기록
5. 실제 속도 계산: (10m / 시간) × 3.6 = km/h
6. 오차율 계산

**데이터 시트**:

| 주행 | 시간(s) | 실제 속도(km/h) | 표시 속도(km/h) | 오차(%) |
|------|---------|-----------------|-----------------|---------|
| 1 | | | | |
| 2 | | | | |
| 3 | | | | |
| 평균 | | | | |

**통과 조건**:
- [ ] 평균 오차 < 5%
- [ ] 최대 오차 < 10%

---

#### 테스트 케이스: TC-SYS-002 - RPM 계산 정확성
**목적**: 바퀴 RPM 계산 검증

**절차**:
1. PiRacer를 고정 속도로 주행
2. 비디오로 바퀴 회전 촬영 (슬로우 모션)
3. 10초간 회전 수 카운트
4. 실제 RPM 계산
5. 화면 표시 RPM과 비교

**통과 조건**:
- [ ] 오차 < 10%

---

#### 테스트 케이스: TC-SYS-003 - 배터리 표시 정확성
**목적**: 배터리 전압 및 퍼센트 표시 검증

**준비물**:
- 멀티미터 (디지털)

**절차**:
1. 멀티미터로 배터리 전압 측정
2. 화면 표시 전압 확인
3. 오차 계산
4. 충전 후 재측정 (100% 확인)
5. 방전 테스트 (20% 경고 확인)

**통과 조건**:
- [ ] 전압 오차 < 0.2V
- [ ] 퍼센트 오차 < 5%
- [ ] 20% 이하 시 빨간색 + 깜빡임

---

#### 테스트 케이스: TC-SYS-004 - 최고 속도 기록
**목적**: 최고 속도 추적 및 리셋 기능 검증

**절차**:
1. 천천히 주행 (10 km/h)
2. 가속 (20 km/h)
3. 최고 속도 표시 확인: "Max: 20.0 km/h"
4. 감속 후에도 유지되는지 확인
5. Reset 버튼 클릭
6. 최고 속도가 0으로 리셋되는지 확인

**통과 조건**:
- [ ] 최고 속도 정확히 추적
- [ ] 감속 후에도 유지
- [ ] Reset 버튼 작동
- [ ] 신기록 시 깜빡임 효과

---

#### 테스트 케이스: TC-SYS-005 - 주행 시간
**목적**: 타이머 정확성 검증

**절차**:
1. 애플리케이션 시작
2. 스톱워치 동시 시작
3. 5분 대기
4. 화면 표시 시간과 스톱워치 비교

**통과 조건**:
- [ ] 오차 < 1초 (5분 기준)

---

### 4.2 성능 테스트

#### 테스트 케이스: TC-PERF-001 - 프레임 레이트
**목적**: 60 FPS 유지 여부 확인

**측정 방법**:
```cpp
// 코드에 FPS 카운터 추가
int frameCount = 0;
QElapsedTimer fpsTimer;
fpsTimer.start();

// paintEvent() 내부
frameCount++;
if (fpsTimer.elapsed() >= 1000) {
    qDebug() << "FPS:" << frameCount;
    frameCount = 0;
    fpsTimer.restart();
}
```

**통과 조건**:
- [ ] 평균 FPS ≥ 55
- [ ] 최소 FPS ≥ 30
- [ ] FPS 변동 < 10

---

#### 테스트 케이스: TC-PERF-002 - CPU 사용률
**목적**: CPU 사용률 < 20% 검증

**측정 방법**:
```bash
top -p $(pgrep dashboard) -b -n 60 > cpu_usage.log
# 60초간 1초 간격 측정
```

**분석**:
```bash
grep dashboard cpu_usage.log | awk '{sum+=$9; count++} END {print "Average CPU:", sum/count "%"}'
```

**통과 조건**:
- [ ] 평균 CPU < 20%
- [ ] 최대 CPU < 40%

---

#### 테스트 케이스: TC-PERF-003 - 메모리 사용
**목적**: 메모리 누수 검사

**측정 방법**:
```bash
valgrind --leak-check=full --show-leak-kinds=all ./dashboard 2> valgrind.log
# 5분 작동 후 종료
```

**통과 조건**:
- [ ] 메모리 사용량 < 100MB
- [ ] 메모리 누수 없음 ("definitely lost: 0 bytes")

---

#### 테스트 케이스: TC-PERF-004 - 응답 지연
**목적**: 사용자 입력 응답 시간 측정

**측정 항목**:

| 동작 | 목표 시간 | 측정 시간 | 통과 여부 |
|------|-----------|-----------|-----------|
| Reset 버튼 클릭 | < 50ms | | |
| 속도 변화 반영 | < 200ms | | |
| 배터리 업데이트 | < 500ms | | |

**통과 조건**: 모든 항목 목표 시간 이내

---

### 4.3 안정성 테스트

#### 테스트 케이스: TC-STAB-001 - 장시간 작동
**목적**: 2시간 연속 작동 안정성 검증

**절차**:
1. 애플리케이션 시작
2. 시뮬레이션 데이터 또는 실제 주행
3. 2시간 동안 모니터링
4. 크래시, 프리징, 메모리 누수 확인

**모니터링 항목**:
- CPU 사용률 (5분 간격)
- 메모리 사용량 (5분 간격)
- 화면 업데이트 정상 여부
- 로그 에러 메시지

**통과 조건**:
- [ ] 크래시 없음
- [ ] 프리징 없음
- [ ] 메모리 증가 < 10MB
- [ ] 모든 기능 정상 작동

---

#### 테스트 케이스: TC-STAB-002 - 연결 불안정 상황
**목적**: 시리얼 연결 끊김/재연결 반복 테스트

**절차**:
1. 정상 작동 중
2. USB 케이블 분리 (10초)
3. 재연결
4. 10회 반복

**통과 조건**:
- [ ] 매번 자동 재연결 성공
- [ ] 애플리케이션 크래시 없음
- [ ] 에러 메시지 적절히 표시

---

#### 테스트 케이스: TC-STAB-003 - 빠른 속도 변화
**목적**: 급가속/급감속 시 안정성 검증

**절차**:
1. 0 → 최고속도 급가속 (5회)
2. 최고속도 → 0 급감속 (5회)
3. 지그재그 속도 변화 (30초)
4. 화면 표시 정상 여부 확인

**통과 조건**:
- [ ] 바늘 애니메이션 끊김 없음
- [ ] 숫자 표시 정확
- [ ] 프리징 없음

---

## 5. 실차 테스트 (Field Tests)

### 5.1 실외 주행 테스트

#### 테스트 케이스: TC-FIELD-001 - 일반 주행
**환경**: 실외 평지, 맑은 날

**절차**:
1. 직선 주행 (50m)
2. 곡선 주행 (S자)
3. 가속/감속 반복
4. 정지/재시작

**체크리스트**:
- [ ] 화면 가독성 (햇빛 아래)
- [ ] 모든 센서 데이터 정상
- [ ] 진동에도 터치 입력 정상
- [ ] 배터리 표시 정확

---

#### 테스트 케이스: TC-FIELD-002 - 배터리 방전 시나리오
**목적**: 배터리 완충 → 방전까지 전체 테스트

**절차**:
1. 완충 상태 (8.4V, 100%)
2. 연속 주행
3. 배터리 상태 기록 (10% 단위)
4. 20% 도달 시 경고 확인
5. 10% 도달 시 동작 확인

**데이터 시트**:

| 배터리 % | 전압(V) | 색상 | 깜빡임 | 기타 |
|----------|---------|------|--------|------|
| 100 | 8.4 | 녹색 | X | |
| 80 | 8.0 | 녹색 | X | |
| 50 | 7.4 | 노란색 | X | |
| 20 | 6.8 | 빨간색 | O | |
| 10 | 6.5 | 빨간색 | O | |

**통과 조건**:
- [ ] 색상 전환 정확
- [ ] 20% 이하 경고 작동

---

### 5.2 환경 테스트

#### 테스트 케이스: TC-ENV-001 - 온도 범위
**환경**:
- 저온: 5°C (이른 아침)
- 고온: 35°C (한낮)

**통과 조건**:
- [ ] 모든 온도에서 정상 작동
- [ ] 화면 응답 속도 정상

---

#### 테스트 케이스: TC-ENV-002 - 진동 내성
**절차**:
1. 울퉁불퉁한 지면 주행
2. 터치스크린 입력 테스트
3. 화면 표시 정상 여부

**통과 조건**:
- [ ] 터치 입력 정상
- [ ] 그래픽 깨짐 없음

---

## 6. 사용성 테스트 (Usability Tests)

### 6.1 UI 가독성

#### 테스트 케이스: TC-UI-001 - 가독성 평가
**참가자**: 3-5명

**평가 항목**:

| 항목 | 평가 기준 | 점수 (1-5) |
|------|-----------|------------|
| 숫자 크기 | 7인치 화면에서 읽기 쉬운가? | |
| 색상 대비 | 배경과 텍스트 구분 명확한가? | |
| 애니메이션 | 바늘 움직임이 자연스러운가? | |
| 레이아웃 | 정보 배치가 직관적인가? | |
| 버튼 크기 | 터치하기 적절한가? | |

**통과 조건**: 모든 항목 평균 ≥ 4점

---

#### 테스트 케이스: TC-UI-002 - 색상 구분
**목적**: 색맹 사용자 고려

**절차**:
1. 온라인 색맹 시뮬레이터 사용
2. 스크린샷을 색맹 모드로 변환
3. 정보 구분 가능한지 확인

**통과 조건**:
- [ ] 속도와 RPM 구분 가능
- [ ] 경고 색상 인식 가능

---

### 6.2 직관성 테스트

#### 테스트 케이스: TC-UI-003 - 첫 사용자 테스트
**참가자**: 계기판 사전 정보 없는 사용자 3명

**질문**:
1. 현재 속도는 얼마인가? (정답률)
2. 최고 속도 기록은? (정답률)
3. 배터리 잔량은? (정답률)
4. 최고 속도를 리셋하려면? (성공률)

**통과 조건**:
- [ ] 모든 질문 정답률 > 80%
- [ ] Reset 버튼 찾기 성공률 > 90%

---

## 7. 버그 추적 및 해결

### 7.1 버그 리포트 템플릿

```markdown
## 버그 ID: BUG-XXX
**발견 날짜**: 2026-XX-XX
**발견자**: 이름
**심각도**: Critical / High / Medium / Low

### 현상
(버그 설명)

### 재현 방법
1. 
2. 
3. 

### 기대 동작
(정상 동작 설명)

### 실제 동작
(버그 동작 설명)

### 스크린샷/로그
(첨부)

### 환경
- OS 버전:
- Qt 버전:
- 하드웨어:

### 상태
- [ ] Open
- [ ] In Progress
- [ ] Fixed
- [ ] Verified
- [ ] Closed
```

---

## 8. 최종 검증 체크리스트

### 8.1 기능 완성도

- [ ] 중앙 속도계 (바늘 + 숫자)
- [ ] 좌측 RPM 게이지
- [ ] 우측 방향 표시 (F/R)
- [ ] 우측 배터리 표시 (%, V, 색상)
- [ ] 주행 시간
- [ ] 최고 속도 기록
- [ ] Reset 버튼
- [ ] 시리얼 통신
- [ ] Python 배터리 읽기

### 8.2 성능 기준

- [ ] FPS ≥ 55
- [ ] CPU < 20%
- [ ] 메모리 < 100MB
- [ ] 응답 지연 < 50ms (버튼)

### 8.3 안정성 기준

- [ ] 2시간 무정지 작동
- [ ] 메모리 누수 없음
- [ ] 자동 재연결 기능
- [ ] 크래시 없음

### 8.4 정확도 기준

- [ ] 속도 오차 < 5%
- [ ] RPM 오차 < 10%
- [ ] 배터리 오차 < 5%
- [ ] 시간 오차 < 1초/5분

### 8.5 사용성 기준

- [ ] 가독성 평가 ≥ 4/5
- [ ] 첫 사용자 정답률 > 80%
- [ ] 터치 버튼 성공률 > 95%

---

## 9. 검증 일정

| 단계 | 시작일 | 종료일 | 담당자 | 상태 |
|------|--------|--------|--------|------|
| 단위 테스트 | Day 2 | Day 3 | 개발자 | |
| 통합 테스트 | Day 4 | Day 5 | 개발자 | |
| 시스템 테스트 | Day 6 | Day 7 | 개발자 | |
| 실차 테스트 | Day 8 | Day 8 | 팀 전체 | |
| 사용성 테스트 | Day 9 | Day 9 | 외부 참가자 | |
| 최종 검증 | Day 10 | Day 10 | PM | |

---

## 10. 승인

### 검증 완료 서명

**단위 테스트**: ________________ (날짜: ______)  
**통합 테스트**: ________________ (날짜: ______)  
**시스템 테스트**: ________________ (날짜: ______)  
**실차 테스트**: ________________ (날짜: ______)  
**최종 승인**: ________________ (날짜: ______)

---

## 11. 참고 문서

- `HARDWARE_ANALYSIS.md`: 하드웨어 제약사항
- `SPECIFICATION.md`: 기능 명세
- `IMPLEMENTATION_PLAN.md`: 구현 계획

---

**작성자**: Ahn Hyunjun  
**검토자**: ________________  
**승인자**: ________________  
**날짜**: 2026-02-16
